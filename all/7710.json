{
  "previous": "%RsXkujw/8Wf/18d1umao02R2nOxvkO5rZ0tEBDmO038=.sha256",
  "author": "@+oaWWDs8g73EZFUMfW37R/ULtFEjwKN/DczvdYihjbU=.ed25519",
  "sequence": 7710,
  "timestamp": 1543523261895,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%RZW7keS4V1Fv4AvUaVvdo7A4hgtLZOdoKDWXByALdE8=.sha256",
    "branch": "%jA8CDnBRDjfm/mWI42a/UblUwAxNAfJySbzDPK/+37s=.sha256",
    "channel": "ssbc",
    "text": "[@kas](@RuNxm8SRujPcJx6GjtTQHp6hprAFv5voEkcvoAkB8Pk=.ed25519) \n\nGood recommendation!\n\nMy understanding is that npm does some deduplication by default, but that you can trigger a duplicate by installing dependencies in a specific order over time. For example, in January you could install something that depends on foo@1.x.x which resolves to 1.1.1, and then in February you could install something that depends on foo@1.2.x which resolves to 1.2.2, you *could* get a duplicate because npm tries to avoid a resource-intensive dedupe unless absolutely necessary.\n\n- **If you need the *exact* same version of two modules:** if you need to assert that `require('foo')` in one module deep equals `require('foo')` in another module, you may need to manually dedupe.\n- **If you want to save space:** this likely isn't an issue for most duplicate modules, but if somehow Electron gets duplicated or something then it would be silly *not* to dedupe.\n\nI don't think I've ever been in any of the above scenarios, but it's definitely a useful tool because it saves others from having to dedupe (since their `npm install` will be driven by the lockfile).",
    "mentions": [
      {
        "link": "@RuNxm8SRujPcJx6GjtTQHp6hprAFv5voEkcvoAkB8Pk=.ed25519",
        "name": "kas"
      }
    ]
  },
  "signature": "R/mnGTqkben4NPr+azTGpe70Jn3fCnLOB3aNK7a6BHEQkj9Ozae6s2eZo2YzaDRAIU6BT1jghMuzWxUs+0r6DA==.sig.ed25519"
}