{
  "previous": "%My4++CVxZ33qbUNmPt9SbmxDzBSWf5gcKgjweDxDv3U=.sha256",
  "author": "@+oaWWDs8g73EZFUMfW37R/ULtFEjwKN/DczvdYihjbU=.ed25519",
  "sequence": 6035,
  "timestamp": 1539357080806,
  "hash": "sha256",
  "content": {
    "type": "post",
    "root": "%g3hPVPDEO1Aj/uPl0+J2NlhFB2bbFLIHlty+YuqFZ3w=.sha256",
    "branch": "%H2Z4P6jXROOkAkxeUCmCyfcufgcDW9l92oFXE0U/QTk=.sha256",
    "text": "> i'm very confused by that RFC\n\nThat makes two of us! Now I think the point of the RFC was basically \"you still need to speak HTTP at http://ssb.example.com, and http://example.com/ssb/, please stop trying to make ad hoc protocol extensions\", but on my first pass I thought they were saying \"URI schemes can't specify syntax\" and I didn't get it.\n\n> So I suggest that we have the same versioning policy as Orthodox Judaism, future rabbi may add new interpretations for things not clear from the earlier writings (for example, to interpret electricity as fire) but they may never contradict past rabbi.\n\nI'd like to nominate this as my favorite sentence in the thread.\n\n> it feels like a good left-to-right general-to-specific order\n\nI agree, *and* I think the extensibility is important. For example, if we parse the URI as an array we'd get:\n\n```\n[ 'ssb', 'message', 'sha256', 'abc']\n```\n\nIf we're being liberal in what we accept, I think we should try to handle the message so long as:\n\n- The first element matches `'ssb'`\n- An element matches `'message'`\n- An element to the right of `'message'` is an algorithm that we support\n- The adjacent element to the right to the algorithm element has an encoding that we support\n\nThis means that we could, in the future, do this without breaking backward-compatibility:\n\n```\nssb:private:message:chess:chat:sha256:abc\n```\n\nI think we could spin the semantic hierarchy as `type -> alg -> hash` or `alg -> type -> hash`, but I think the algorithm has such a close affinity to the hash that they should remain adjacent. Given how many encoded integers we have flying around in cypherspace, I don't think we'd want to be in a position where we have `ssb:sha256:messsage:abc:def` and now we have to decide whether the sha256 digest is `abc` or `def`.\n\n> i notice that in Node.js the `url` module's `.parse` function doesn't understand `ssb:message:sha256:abc`\n\nYeah, I've been playing around with [uri-js](https://www.npmjs.com/package/uri-js) for testing, but it's good to know that `url.URL` can handle our URIs correctly. I've been thinking that some future `ssb-uri` might be a useful interface for developers wanting to parse/serialize with the `ssb:` URI scheme."
  },
  "signature": "9Zusxu85mF9aKOYIT/GWAiafA/VvhwhyDKmjSh4fUKbNjtTxbjsuyS1nn6ne+cBpegoAAug5AdRURGH8XAVCBg==.sig.ed25519"
}